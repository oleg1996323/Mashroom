import os
import argparse
from pathlib import Path

def parse_centre_def(path):
    """Парсит centre.def и возвращает словарь subCentre -> описание"""
    centres = {}
    with open(path, 'r') as f:
        for line in f:
            if '=' in line and 'subCentre' in line:
                parts = line.split('=')
                name = parts[0].strip().strip('"')
                sub = int(parts[1].split(';')[0].split('=')[1].strip())
                centres[sub] = name
    return centres

def generate_header(path, output_dir):
    #subcenter = {}
    assertions:str=""
    #parm_tables:str="constexpr const ParmTable* parm_tables[][]={\n"
    """Генерирует .h-файл с таблицами"""
    code = f"""// AUTOGENERATED FILE. DO NOT EDIT.
#pragma once

#include <string>

typedef struct {{
    const char *name, *comment;
}}ParmTable;

"""
    for file in Path(path).iterdir():
        if file.suffix == '.table' and file.name.startswith('2.') and file.name != '2.table':
            table_name = file.stem.removesuffix('.table')
            name_parts = table_name.split('.')
            # if len(name_parts)==2:
            #     table_name = file.stem.split('.')[1]
            # elif len(name_parts)==3:
            #     table_name = file.stem.split('.')[2]
            # else :continue
            code += f"constexpr ParmTable ParmTable_{table_name.replace('.','_').upper()}[] = {{\n"
            # if len(name_parts) == 2:
            #     center = 98  # ECMWF по умолчанию
            #     sub = int(name_parts[1])
            #     if center not in subcenter:
            #         subcenter[center] = {}  # Инициализируем вложенный словарь
            #     subcenter[center][sub] = f"ParmTable_{table_name.replace('.','_').upper()}"
                
            # elif len(name_parts) == 3:
            #     center = int(name_parts[1])
            #     sub = int(name_parts[2])
            #     if center not in subcenter:
            #         subcenter[center] = {}  # Инициализируем вложенный словарь
            #     subcenter[center][sub] = f"ParmTable_{table_name.replace('.','_').upper()}"
            # else:
            #     continue
            #parm_tables+=f"ParmTable_{file.name.replace('.','_').upper()},\n"
            assertions+=f"static_assert(sizeof(ParmTable_{table_name.replace('.','_').upper()})/sizeof(ParmTable_{table_name.replace('.','_').upper()}[0])==256);\n"
            with open(file, 'r') as f:
                count = 0
                for line in f:
                    if line.startswith('#'):
                        continue
                    line = line.strip()
                    if not line:
                        continue
                    
                    # Разбиваем строку на 3 компонента: номер, название, описание
                    parts = line.split(maxsplit=2)  # maxsplit=2 для сохранения описания
                    if len(parts) < 3:
                        continue
                    
                    num, name, comment = parts

                    while int(num)>count and count<256:
                        code += f'    {{"Unknown", "Unknown"}}, //{count}\n'
                        count+=1
                    code += f'    {{"{name}", "{comment}"}}, //{count}\n'
                    count+=1
                while count<256:
                    code += f'    {{"Unknown", "Unknown"}}, //{count}\n'
                    count+=1
            code += "};\n\n"

    #parm_tables+=f"ParmTable_{file.name.replace('.','_').upper()},\n"
    # parm_list:list[list[str]] = []
    # for center,parm_table in sorted(subcenter.items()):
    #     count_1 = 0
    #     while center>count_1 and count_1<256:
    #         parm_list.append([])
    #         count_1+=1
    #     sublist:list[str]=[]
    #     for subcenter,txt in sorted(parm_table.items()):
    #         count_2 = 0
    #         while subcenter>count_2 and count_2<256:
    #             sublist.append("NULL")
    #             count_2+=1
    #         sublist.append(txt)
    #     while count_2<256:
    #         sublist.append("NULL")
    #         count_2+=1
    #     parm_list.append(sublist)
    # while center>count_1 and count_1<256:
    #     parm_list.append([])
    #     count_1+=1

    
    os.makedirs(output_dir, exist_ok=True)
    code+=assertions
    # for list_1 in parm_list:
    #     if len(list_1)!=0:
    #         parm_tables+='{'
    #         for list_2 in list_1:
    #             parm_tables+=list_2+",\n"
    #         parm_tables+='},\n'
    # parm_tables+='};\n'

    # print(parm_tables)
    # code+=parm_tables
    with open(f"{output_dir}/eccodes_tables.h", 'w') as f:
        f.write(code)

if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument('--src', required=True)
    parser.add_argument('--out', required=True)
    args = parser.parse_args()

    #centres = parse_centre_def(Path(args.src) / "localConcepts/ecmf/centre.def")
    generate_header(Path(args.src), args.out)
