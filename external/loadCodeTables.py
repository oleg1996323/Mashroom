import os
import argparse
from pathlib import Path

def parse_centre_def(path):
    """Парсит centre.def и возвращает словарь subCentre -> описание"""
    centres = {}
    with open(path, 'r') as f:
        for line in f:
            if '=' in line and 'subCentre' in line:
                parts = line.split('=')
                name = parts[0].strip().strip('"')
                sub = int(parts[1].split(';')[0].split('=')[1].strip())
                centres[sub] = name
    return centres

def generate_header(path, output_dir):
    center_dict = {}
    switcher = "const ParmTable* parameter_table(unsigned char center, unsigned char table_version, unsigned char param_num){\n"\
        "    switch(center){\n"
    assertions=""
    #parm_tables:str="constexpr const ParmTable* parm_tables[][]={\n"
    """Генерирует .h-файл с таблицами"""
    code = f"""// AUTOGENERATED FILE. DO NOT EDIT.
#pragma once
#include <cstdlib>

typedef struct {{
    const char *name, *comment;
}}ParmTable;

"""
    for file in Path(path).iterdir():
        if file.suffix == '.table' and file.name.startswith('2.') and file.name != '2.table':
            table_name = file.stem.removesuffix('.table')
            name_parts = table_name.split('.')
            # if len(name_parts)==2:
            #     table_name = file.stem.split('.')[1]
            # elif len(name_parts)==3:
            #     table_name = file.stem.split('.')[2]
            # else :continue
            code += f"constexpr ParmTable ParmTable_{table_name.replace('.','_').upper()}[] = {{\n"
            if len(name_parts) == 2:
                center = 98  # ECMWF по умолчанию
                sub = int(name_parts[1])
                if center not in center_dict:
                    center_dict[center] = {}  # Инициализируем вложенный словарь
                center_dict[center][sub]=f"&ParmTable_{table_name.replace('.','_').upper()}[param_num]"
                
            elif len(name_parts) == 3:
                center = int(name_parts[1])
                sub = int(name_parts[2])
                if center not in center_dict:
                    center_dict[center] = {}  # Инициализируем вложенный словарь
                center_dict[center][sub]=f"&ParmTable_{table_name.replace('.','_').upper()}[param_num]"
            else:
                continue
            #parm_tables+=f"ParmTable_{file.name.replace('.','_').upper()},\n"
            assertions+=f"static_assert(sizeof(ParmTable_{table_name.replace('.','_').upper()})/sizeof(ParmTable_{table_name.replace('.','_').upper()}[0])==256);\n"
            with open(file, 'r') as f:
                count = 0
                for line in f:
                    if line.startswith('#'):
                        continue
                    line = line.strip()
                    if not line:
                        continue
                    
                    # Разбиваем строку на 3 компонента: номер, название, описание
                    parts = line.split(maxsplit=2)  # maxsplit=2 для сохранения описания
                    if len(parts) < 3:
                        continue
                    
                    num, name, comment = parts
                    comment = comment.replace('\\',r'\\')

                    while int(num)>count and count<256:
                        code += f'    {{"Unknown", "Unknown"}}, //{count}\n'
                        count+=1
                    code += fr'    {{"{name}", "{comment}"}}, //{count}'+'\n'
                    count+=1
                while count<256:
                    code += f'    {{"Unknown", "Unknown"}}, //{count}\n'
                    count+=1
            code += "};\n\n"
    
    for center,table_version_data in center_dict.items():
        switcher+=f"    case {center}:\n"\
        "    switch(table_version){\n"
        for table_version,str in table_version_data.items():
            switcher+=f"        case {table_version}:\n"\
            f"          return {str};\n"\
            "           break;\n"
        switcher+="        default:\n"\
        "        return nullptr;\n"\
        "        break;\n    }\n"

    switcher+="    default:\n"\
        "    return nullptr;\n"\
        "    break;\n    }\n}\n"

    #parm_tables+=f"ParmTable_{file.name.replace('.','_').upper()},\n"
    # parm_list:list[list[str]] = []
    # for center,parm_table in sorted(table_version.items()):
    #     count_1 = 0
    #     while center>count_1 and count_1<256:
    #         parm_list.append([])
    #         count_1+=1
    #     sublist:list[str]=[]
    #     for table_version,txt in sorted(parm_table.items()):
    #         count_2 = 0
    #         while table_version>count_2 and count_2<256:
    #             sublist.append("nullptr")
    #             count_2+=1
    #         sublist.append(txt)
    #     while count_2<256:
    #         sublist.append("nullptr")
    #         count_2+=1
    #     parm_list.append(sublist)
    # while center>count_1 and count_1<256:
    #     parm_list.append([])
    #     count_1+=1
                
    os.makedirs(output_dir+"/include/generated/code_tables", exist_ok=True)
    os.makedirs(output_dir+"/src/generated/code_tables", exist_ok=True)
    code+=assertions+"extern "+switcher.split("{",1)[0]+";"
    # for list_1 in parm_list:
    #     if len(list_1)!=0:
    #         parm_tables+='{'
    #         for list_2 in list_1:
    #             parm_tables+=list_2+",\n"
    #         parm_tables+='},\n'
    # parm_tables+='};\n'

    # print(parm_tables)
    # code+=parm_tables

    with open(f"{output_dir}/include/generated/code_tables/eccodes_tables.h", 'w') as f:
        f.write(code)

    with open(f"{output_dir}/src/generated/code_tables/eccodes_tables.cpp","w") as f:
        f.write(f"#include \"generated/code_tables/eccodes_tables.h\"\n"+
                switcher)

if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument('--src', required=True)
    parser.add_argument('--out', required=True)
    args = parser.parse_args()

    #centres = parse_centre_def(Path(args.src) / "localConcepts/ecmf/centre.def")
    generate_header(Path(args.src), args.out)
